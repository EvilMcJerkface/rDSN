<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>rDSN: Example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rDSN
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Example<div class="ingroups"><a class="el" href="group__dev.html">A Layered Stack for Distributed System Development</a> &raquo; <a class="el" href="group__dev-layer1.html">Zion: Write Robust and High-Performance Applications (layer 1)</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Quickly build a counter service with built-in tools.  
<a href="#details">More...</a></p>
<p>Quickly build a counter service with built-in tools. </p>
<p>We will develop &amp; operate a counter service here and go through many of rDSN's features at layer 1. Before exercising this tutorial, please make sure you have already <a href="https://github.com/Microsoft/rDSN/wiki/Installation">installed</a> rDSN on your machine.</p>
<h3>Quick links</h3>
<p>STEP 1. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-1-write-the-service-interface-and-run">Write the service interface and run!</a> STEP 2. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-2-implement-application-logic">Implement application logic</a> STEP 3. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-3-deploy-with-single-executable-multiple-role-multiple-instance">Deploy with single-executable, multiple-role, multiple-instance</a> STEP 4. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-4-use-toollet---understand-what-is-happening-with-logging">Use Toollet - understand what is happening with logging</a> STEP 5. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-5-view-all-state-in-a-single-debugger-and-debug-wo-worring-about-false-timeouts">View ALL state in a single debugger, and debug w/o worring about false timeouts</a> STEP 6. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-6-deterministic-execution-for-easy-debugging">Deterministic execution for easy debugging</a> STEP 7. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-7-scale-up-the-service">Scale-up the service</a> STEP 8. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-8-systematic-test-against-various-failures-and-scheduling-decisions">Systematic test against various failures and scheduling decisions</a> STEP 9. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-9-understanding-the-performance-using-the-profiler-tool">Understanding the performance using the profiler tool</a> STEP 10. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-10-operate-your-system-with-local-and-remote-cli">Operate your system with local and remote cli</a> STEP 11. Check global correctness using global assertion across nodes STEP 12. Handle system overloading using admission controller STEP 13. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-13-plug-in-your-own-low-level-components-optional">Plug-in your own low level components (optional)</a> STEP 14. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-14-connect-the-service-with-other-languages-optional">Connect the service with other languages (optional)</a> STEP 15. <a href="https://github.com/Microsoft/rDSN/wiki/Tutorial:-Build-A-Single-Node-Counter-Service#step-15-open-service-with-multiple-ports-optional">Open service with multiple ports (optional)</a> STEP 16. <a href="https://github.com/Microsoft/rDSN/wiki/Find-useful-information-of-config.ini">Find more information about the config.ini (optional)</a></p>
<h3>STEP 1. Write the service interface and run!</h3>
<h5>STEP 1.1</h5>
<p>Use the interface definition language from <a href="https://thrift.apache.org/docs/idl">Apache Thrift</a> or <a href="https://developers.google.com/protocol-buffers/docs/proto">Google Protocol Buffers</a> to describe your service interface. In this case, we are using thrift and writing the following interface definition for our service into counter.thrift. </p><div class="fragment"><div class="line">{C++}</div><div class="line"><span class="keyword">namespace </span>cpp <a class="code" href="namespacedsn.html">dsn</a>.example</div><div class="line"></div><div class="line">struct count_op</div><div class="line">{</div><div class="line">   1: <span class="keywordtype">string</span> name;</div><div class="line">   2: i32    operand;</div><div class="line">}</div><div class="line"></div><div class="line">service counter</div><div class="line">{</div><div class="line">    i32 add(1:count_op op);</div><div class="line">    i32 read(1:<span class="keywordtype">string</span> name);</div><div class="line">}</div></div><!-- fragment --><h5>STEP 1.2</h5>
<p>Use our tool <code>dsn.cg.sh</code> or <code>dsn.cg.bat</code> from the <b>installation</b> directory to generate code from the above file. Note we need to have the <a href="https://github.com/imzhenyu/thrift/tree/master/pre-built">enhanced Apache Thrift</a> or <a href="https://github.com/imzhenyu/protobuf/tree/master/pre-built">Google Protoc</a> tool in the sub-directory os-name%(e.g., <a href="https://github.com/Microsoft/rDSN/tree/master/bin/Linux">Linux</a>) of where <code>dsn.cg</code> is installed (done by default now).</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial$ <a class="code" href="namespacedsn.html">dsn</a>.cg.sh counter.thrift cpp counter single</div><div class="line">generate <span class="stringliteral">&#39;counter/CMakeLists.txt&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.app.example.h&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.client.h&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.code.definition.h&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/config.ini&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.main.cpp&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.server.h&#39;</span> successfully!</div><div class="line">generate <span class="stringliteral">&#39;counter/counter.types.h&#39;</span> successfully!</div><div class="line">...</div></div><!-- fragment --><p> An introduction about these files.</p>
<p>counter.main.cpp - the main program, which defines the possible service app and tool <b>roles</b> in the final executable. In this case, the counter server &amp; client service, as well as all the default tools are registered. config.ini - configuration file specifying what are the <b>role instances</b> for services and tools for a particular running process. counter.code.definition.h - defines the event/task code for the RPC calls. counter.client/server.h - define the server and client classes for counter service. counter.app.example.h - an example wrapper about how to put single/multiple client/server into service apps. counter.types.h - how to marshall and unmarshall the request/response messages across network using rDSN's internal binary encoding/decoding. You may also use the ones from Thrift (more). counter.check.h/.cpp - sketch for writing cross-nodes global assertions. CMakeLists.txt - file for cmake.</p>
<h5>STEP 1.3</h5>
<p>Build and run</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial/counter$ mkdir build</div><div class="line">~/projects/rdsn/tutorial/counter$ cd build</div><div class="line">~/projects/rdsn/tutorial/counter/build$ cmake ..</div><div class="line">~/projects/rdsn/tutorial/counter/build$ make -j</div><div class="line">~/projects/rdsn/tutorial/counter/build$ cd bin/counter</div><div class="line">~/projects/rdsn/tutorial/counter/build/bin/counter$ ./counter config.ini</div><div class="line">unknown: simulation.random seed <span class="keywordflow">for</span> <span class="keyword">this</span> round is -970799620</div><div class="line">... exec RPC_COUNTER_COUNTER_READ ... (not implemented)</div><div class="line">call RPC_COUNTER_COUNTER_READ end, <span class="keywordflow">return</span> ERR_SUCCESS</div><div class="line">... exec RPC_COUNTER_COUNTER_ADD ... (not implemented)</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> ERR_SUCCESS</div><div class="line">...</div></div><!-- fragment --><p>Note for the above "cmake .." on Windows, you may encounter certain errors, and you may use the command similar to the following instead.</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial/counter/build$ cmake .. -DCMAKE_INSTALL_PREFIX=c:\rdsn -DBOOST_INCLUDEDIR=<span class="stringliteral">&quot;c:\boost_1_57_0&quot;</span> -DBOOST_LIBRARYDIR=<span class="stringliteral">&quot;c:\boost_1_57_0\lib64-msvc-12.0&quot;</span> -G <span class="stringliteral">&quot;NMake Makefiles&quot;</span></div></div><!-- fragment --><p>Also note for the above "make -j" on Windows, you could build in Visual Studio 2013 instead. Remember to enter "Configuration Manager" to change "Platform" to x64 if necessary. If you meet with problems like "value xx doesn't match value xx xx.obj", you must be confused with "Release" and "Debug".</p>
<h3>STEP 2. Implement application logic</h3>
<p>In order to plug-in the real application logic, we need to write a new service class inheriting <b>counter_service</b> generated in counter.server.h. Note rDSN has some <b><a href="https://github.com/Microsoft/rDSN/wiki/Programming-Rules-and-FAQ">programming rules</a></b> to ensure the built-in tools and frameworks can work.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line"> 6 <span class="keyword">class </span>counter_service_impl : <span class="keyword">public</span> counter_service</div><div class="line"> 7 {</div><div class="line"> 8 <span class="keyword">public</span>:</div><div class="line"> 9    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_add(const ::dsn::example::count_op&amp; op, ::<a class="code" href="classdsn_1_1rpc__replier.html">dsn::rpc_replier&lt;int32_t&gt;</a>&amp; reply)</div><div class="line">10    {</div><div class="line">11        <span class="keyword">auto</span> result = (_counters[op.name] += op.operand);</div><div class="line">12        reply(result);</div><div class="line">13    }</div><div class="line">14</div><div class="line">15    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_read(<span class="keyword">const</span> std::string&amp; name, ::<a class="code" href="classdsn_1_1rpc__replier.html">dsn::rpc_replier&lt;int32_t&gt;</a>&amp; reply)</div><div class="line">16    {</div><div class="line">17        <span class="keyword">auto</span> it = _counters.find(name);</div><div class="line">18        <span class="keyword">auto</span> result = it != _counters.end() ? it-&gt;second : 0;</div><div class="line">19        reply(result);</div><div class="line">20    }</div><div class="line">21</div><div class="line">22 <span class="keyword">private</span>:</div><div class="line">23    std::map&lt;std::string, int32_t&gt; _counters;</div><div class="line">24 };</div></div><!-- fragment --><p> To integrate the new class into the real execution, we need to change the member service in class <b>counter_server_app</b> from <b>counter_service</b> to <b>counter_service_impl</b>. We also change the logic in <b>counter_client_app</b> to do some meaningful test (all in <b>counter.app.example.h</b>). </p><div class="fragment"><div class="line">{C++}</div><div class="line">90 ::dsn::example::count_op req = {<span class="stringliteral">&quot;counter1&quot;</span>, 1}; </div><div class="line">94 std::cout &lt;&lt; <span class="stringliteral">&quot;call RPC_COUNTER_COUNTER_ADD end, return &quot;</span> &lt;&lt; resp &lt;&lt; <span class="stringliteral">&quot;, err = &quot;</span> &lt;&lt; err.to_string() &lt;&lt; std::endl; </div><div class="line">...</div></div><!-- fragment --><p> After re-compiling and executing the program, we get: </p><div class="fragment"><div class="line">~/projects/rdsn/tutorial/counter/build/bin/counter$ ./counter config.ini</div><div class="line">unknown: simulation.random seed <span class="keywordflow">for</span> <span class="keyword">this</span> round is -1139212112</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> 1, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_READ end, <span class="keywordflow">return</span> 1, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> 2, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_READ end, <span class="keywordflow">return</span> 2, err = ERR_SUCCESS</div><div class="line">...</div></div><!-- fragment --><p> rDSN provides both synchronous and asynchronous client access for the service as in <b>counter.client.h</b> in this case. To use asynchronous client, developers implement customized handlers to process the response from the server, e.g., <b>end_add</b> and <b>end_read</b> in this case. We skip here for simplicity.</p>
<h3>STEP 3. Deploy with single-executable, multiple-role, multiple-instance</h3>
<p>You may already feel strange that we don't start a client and a server separately for the above exercises. rDSN advocates a single-executable, multiple-role, multiple-instance deployment model. In the above case, both the client and the server roles are registered in <b>main</b> of the host process, so their execution code are within the same executable after compilation. In order to enable this, rDSN actually has some rules like no global variables etc. to avoid confliction, see <a href="https://github.com/Microsoft/rDSN/wiki/Programming-Rules-and-FAQ">here</a> for more information.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line">{</div><div class="line">  <span class="comment">// register all possible service apps</span></div><div class="line">  dsn::service::system::register_service&lt;::dsn::example::counter_server_app&gt;(<span class="stringliteral">&quot;counter_server&quot;</span>);</div><div class="line">  dsn::service::system::register_service&lt;::dsn::example::counter_client_app&gt;(<span class="stringliteral">&quot;counter_client&quot;</span>);</div><div class="line"></div><div class="line">  <span class="comment">// register all possible tools and toollets</span></div><div class="line">  dsn::tools::register_tool&lt;dsn::tools::nativerun&gt;(<span class="stringliteral">&quot;nativerun&quot;</span>);</div><div class="line">  dsn::tools::register_tool&lt;dsn::tools::simulator&gt;(<span class="stringliteral">&quot;simulator&quot;</span>);</div><div class="line">  ...</div></div><!-- fragment --><p>When for the real execution, what roles and how many instances for each role as well as their arguments are specified in the configuration file. The following configuration starts one server and one client for the given process.</p>
<div class="fragment"><div class="line">[apps.server]</div><div class="line">name = server</div><div class="line">type = counter_server</div><div class="line">arguments = </div><div class="line">ports = 27001</div><div class="line">run = <span class="keyword">true</span></div><div class="line"></div><div class="line">[apps.client]</div><div class="line">name = client</div><div class="line">type = counter_client</div><div class="line">arguments = localhost 27001</div><div class="line">count = 1</div><div class="line">run = <span class="keyword">true</span></div></div><!-- fragment --><p>You may also notice that we also register <b>tools</b> etc. in the above <b>main</b> function. Similarly, the configuration file specifies what tools should be started for a given run.</p>
<div class="fragment"><div class="line">[core]</div><div class="line">;tool = simulator</div><div class="line">tool = nativerun</div></div><!-- fragment --><p> We may try <b>nativerun</b> in this case. Then re-run the application (no need to re-compile).</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial/counter/build/bin/counter$ ./counter config.ini</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> 1, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_READ end, <span class="keywordflow">return</span> 1, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> 2, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_READ end, <span class="keywordflow">return</span> 2, err = ERR_SUCCESS</div><div class="line">...</div></div><!-- fragment --><p>You won't see differences except that the output becomes much slower. This is because with the native run tool, we are emitting client requests every 1 physical second, while with the simulator tool, 1 second is much faster. Next, we can change the configuration in config.ini so the client and the server are deployed as two different processes (possibly on two remote machines then). Or, we can simply use the following commands to start the client and server respectively in two separated processes. Note in this case <code>[core]tool = nativerun</code> must be set to ensure they can communicate with each other.</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial/counter/build/bin/counter$ ./counter config.ini -app_list server</div><div class="line">~/projects/rdsn/tutorial/counter/build/bin/counter$ ./counter config.ini -app_list client</div></div><!-- fragment --><h3>STEP 4. Use Toollet - understand what is happening with logging</h3>
<p>Logging is still the most widely adopted mechanism to understand what happens in the system. Instead of manually and intensively writing <b>printf</b> in the code, rDSN provides the <b>tracer</b> tool with automatic logging. To load the tracer tool, we need to add <b>tracer</b> to the <b>toollets</b> list under <b>[core]</b> section. A toollet is similar to a <b>tool</b> like <b>simulator</b> and <b>nativerun</b>, except that it can co-exist with the other toollets and tools, while <b>tools</b> conflict with each other.</p>
<div class="fragment"><div class="line">[core]</div><div class="line">tool = simulator</div><div class="line">;tool = nativerun</div><div class="line">toollets = tracer</div><div class="line">;toollets = tracer, profiler, fault_injector</div><div class="line">pause_on_start = <span class="keyword">false</span></div><div class="line"></div><div class="line">logging_factory_name = dsn::tools::screen_logger</div></div><!-- fragment --><p>With the tracer tool, here is what we can see. Note for simplicity, unless explicitly specified, we will all use the <b>simulator</b> tool and enable both client and server in the configuration from now on.</p>
<div class="fragment"><div class="line">...</div><div class="line">client.default.0: RPC_COUNTER_COUNTER_ADD RPC.CALL: localhost:1 =&gt; localhost:27001, rpc_id = e3f394e0d2eae776, callback_task = 00000000012b0000, timeout = 5000ms</div><div class="line">client.default.0: RPC_COUNTER_COUNTER_ADD RPC.REQUEST.ENQUEUE, task_id = 00000000012acf80, localhost:1 =&gt; localhost:27001, rpc_id = e3f394e0d2eae776</div><div class="line">server.default.0: RPC_COUNTER_COUNTER_ADD EXEC BEGIN, task_id = 00000000012acf80, localhost:1 =&gt; localhost:27001, rpc_id = e3f394e0d2eae776</div><div class="line">server.default.0: RPC_COUNTER_COUNTER_ADD_ACK RPC.REPLY: localhost:27001 =&gt; localhost:1, rpc_id = e3f394e0d2eae776</div><div class="line">server.default.0: RPC_COUNTER_COUNTER_ADD_ACK RPC.RESPONSE.ENQUEUE, task_id = 00000000012b0000, localhost:27001 =&gt; localhost:1, rpc_id = e3f394e0d2eae776</div><div class="line">client.default.0: RPC_COUNTER_COUNTER_ADD_ACK EXEC BEGIN, task_id = 00000000012b0000, localhost:27001 =&gt; localhost:1, rpc_id = e3f394e0d2eae776</div><div class="line">client.default.0: RPC_COUNTER_COUNTER_ADD_ACK EXEC END, task_id = 00000000012b0000, err = ERR_SUCCESS</div><div class="line">server.default.0: RPC_COUNTER_COUNTER_ADD EXEC END, task_id = 00000000012acf80, err = ERR_SUCCESS</div><div class="line">call RPC_COUNTER_COUNTER_ADD end, <span class="keywordflow">return</span> 1, err = ERR_SUCCESS</div><div class="line">...</div></div><!-- fragment --><p> Every log entry starts with a header like "client.default.0", which means it was on the node with name 'client', in the thread pool named "default", and executed by the thread with index 0. Our tracing tool instruments all the asynchronous points in the system, therefore in this case you can easily see how the <b>RPC_COUNTER_COUNTER_ADD</b> request is processed in the system.</p>
<p>The tracing tool also comes with fine-grain configuration, shown below. We turn on tracing for all tasks by default, and put LPC_RPC_TIMEOUT as an exception because it is an internal task used by RPC engine in rDSN.</p>
<div class="fragment"><div class="line">[task.default]</div><div class="line">is_trace = <span class="keyword">true</span></div><div class="line"></div><div class="line">[task.LPC_RPC_TIMEOUT]</div><div class="line">is_trace = <span class="keyword">false</span></div></div><!-- fragment --><h3>STEP 5. View ALL state in a single debugger, and debug w/o worring about false timeouts</h3>
<p>A distributed system is composed of multiple nodes. Since rDSN enables all nodes running in one single physical node, we can pause the whole system in a debugger, and inspect all memory state easily. rDSN provides a special symbol called <b>dsn_all</b> (or <b>dsn_all</b> and <b>dsn_apps</b> in the future) for tracking most of the variables in the system (e.g., all app instances, all tools, and the engine). Following is a case showing the global state (not for this case though).</p>
<div class="image">
<img src="https://raw.githubusercontent.com/Microsoft/rDSN/master/resources/rdsn-state-all.jpg"  alt="dsn_all"/>
</div>
<p>Because we can use <b>simualtor</b> as our underlying tool when debugging, which virtualizes the time, we don't need to worry about false timeout at all when pausing and inspecting the memory state in debugger - a common annoying problem when debugging distributed systems.</p>
<h3>STEP 6. Deterministic execution for easy debugging</h3>
<p>Implementing the application logic usually requires many rounds of try-and-error before it can be stabilized. rDSN provides deterministic execution in simulator so as to repeatedly produce the same state sequence for easy diagnosis.</p>
<div class="fragment"><div class="line">[core]</div><div class="line">tool = simulator</div><div class="line"></div><div class="line">[tools.simulator]</div><div class="line">random_seed = 2756568580</div></div><!-- fragment --><p>The non-determinism of the whole system is now determined by a single <code>random_seed</code> as shown above. When the seed is non-zero, the system is deterministic as long as the random seed does not change. When the seed is zero, the system is non-deterministic.</p>
<h3>STEP 7. Scale-up the service</h3>
<p>So far, we are using only 1 thread for serving the client requests because <b>RPC_COUNTER_COUNTER_ADD</b> and <b>RPC_COUNTER_COUNTER_READ</b> requests are handled by the <b>default</b> thread pool, and in the configuration file, we have <b>[threadpool.THREAD_POOL_DEFAULT] worker_count = 1</b>. To scale up the service, we increase the number of threads to 4. However, the service handlers in <b>counter.service.impl.h</b> must also be made thread safe, by using a lock with type **<a class="el" href="classdsn_1_1service_1_1zrwlock__nr.html">dsn::service::zrwlock_nr</a>**. In rNET_HDR_DSN, all non-deterministic behaviors must be implemented using rDSN's service API (see <a href="https://github.com/Microsoft/rDSN/wiki/Programming-Rules-and-FAQ">here</a>). However, if you are in favor of some other reader-writer locks, you can still use them by integrating them as rwlock providers as we do with logging providers above.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line"> 10 <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_add(const ::dsn::example::count_op&amp; op, ::dsn::service::rpc_replier&lt;int32_t&gt;&amp; reply)</div><div class="line"> 11 {</div><div class="line"> 12   <a class="code" href="classdsn_1_1service_1_1zauto__write__lock.html">::dsn::service::zauto_write_lock</a> l(_lock);</div><div class="line"> 13   <span class="keyword">auto</span> result = (_counters[op.name] += op.operand);</div><div class="line"> 14   reply(result);</div><div class="line"> 15 }</div><div class="line"> 16</div><div class="line"> 17 <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_read(<span class="keyword">const</span> std::string&amp; name, ::dsn::service::rpc_replier&lt;int32_t&gt;&amp; reply)</div><div class="line"> 18 {</div><div class="line"> 19   <a class="code" href="classdsn_1_1service_1_1zauto__read__lock.html">::dsn::service::zauto_read_lock</a> l(_lock);</div><div class="line"> 20   <span class="keyword">auto</span> it = _counters.find(name);</div><div class="line"> 21   <span class="keyword">auto</span> result = it != _counters.end() ? it-&gt;second : 0;</div><div class="line"> 22   reply(result);</div><div class="line"> 23 }</div><div class="line"> 24</div><div class="line"> 25 <span class="keyword">private</span>:</div><div class="line"> 26 <a class="code" href="classdsn_1_1service_1_1zrwlock__nr.html">::dsn::service::zrwlock_nr</a> _lock;</div></div><!-- fragment --><p>Another approach without using locks is to partition the counter name space so that the <b>ADD</b> and <b>READ</b> with the same counter name will always be executed by a same thread. rDSN supports this by introducing <b>partitioned</b> thread pools, which is simply enabled by setting <b>[threadpool.SOME_POOL_CODE] partitioned = true</b>. When emitting a task to be handled by a partitioned thread pool, a <b>hash</b> value needs to be specified so that the thread with index <b>hash % worker_count</b> will serve the task. You can find this parameter in our generate client code.</p>
<p>At this point, we want to introduce <b>declarative configuration among CPU cores, threads, and tasks</b> in rNET_HDR_DSN, which is important when there are a lot more kinds of tasks in the system. Following is an example (not for our tutorial) where on a machine with four CPU cores, we define two thread pools, and they use one and three cores respectively to avoid interference (e.g., many RPC_COUNTER_READ pending tasks block execution of RPC_COUNTER_ADD). Note we also change the default timeout and channel for RPC calls.</p>
<div class="fragment"><div class="line">[threadpool.THREAD_POOL_COUNTER_DEFAULT]</div><div class="line">name = counter update</div><div class="line">worker_count = 1</div><div class="line">worker_affinity_mask = 0x1 # first core</div><div class="line"></div><div class="line">[threadpool.THREAD_POOL_DEFAULT]</div><div class="line">name = counter read</div><div class="line">worker_count = 6</div><div class="line">worker_affinity_mask = 0xE # later three core</div><div class="line"></div><div class="line">[task.RPC_COUNTER_ADD]</div><div class="line">pool_code = THREAD_POOL_COUNTER_DEFAULT</div><div class="line">rpc_timeout_milliseconds = 1000</div><div class="line">rpc_message_channel = RPC_CHANNEL_UDP</div><div class="line"></div><div class="line">[task.RPC_COUNTER_READ]</div><div class="line">pool_code = THREAD_POOL_DEFAULT</div><div class="line">rpc_timeout_milliseconds = 500</div><div class="line">rpc_message_channel = RPC_CHANNEL_UDP</div></div><!-- fragment --><h3>STEP 8. Systematic test against various failures and scheduling decisions</h3>
<p>rDSN provides a fault injector together with the simulator to systematically test your system against various failures (e.g., message delay, message lost, task scheduling re-ordering, disk failure, very long task execution), to expose early the possible bugs. Note in this case, we first add an "assert" in our client code to ensure the second read always get the same value as we get with the first add operation when both error codes are ok. Then we set client count in configuration to 2 to see what happens.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line"><span class="keywordtype">void</span> on_test_timer()</div><div class="line">{</div><div class="line">    int32_t resp2, resp1;</div><div class="line">    <a class="code" href="classdsn_1_1error__code.html">::dsn::error_code</a> err1, err2;</div><div class="line"></div><div class="line">    <span class="comment">// test for service &#39;counter&#39;</span></div><div class="line">    {</div><div class="line">        count_op req = {<span class="stringliteral">&quot;counter1&quot;</span>, 1};</div><div class="line">        <span class="comment">//sync:</span></div><div class="line">        err1 = _counter_client-&gt;add(req, resp1);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;call RPC_COUNTER_COUNTER_ADD end, return &quot;</span> &lt;&lt; resp1 &lt;&lt; <span class="stringliteral">&quot;, err = &quot;</span> &lt;&lt; err1.to_string() &lt;&lt; std::endl;</div><div class="line">        <span class="comment">//async: </span></div><div class="line">        <span class="comment">//_counter_client-&gt;begin_add(req);</span></div><div class="line"></div><div class="line">    }</div><div class="line">    {</div><div class="line">        std::string req = <span class="stringliteral">&quot;counter1&quot;</span>;</div><div class="line">        <span class="comment">//sync:</span></div><div class="line">        err2 = _counter_client-&gt;read(req, resp2);</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;call RPC_COUNTER_COUNTER_READ end, return &quot;</span> &lt;&lt; resp2 &lt;&lt; <span class="stringliteral">&quot;, err = &quot;</span> &lt;&lt; err2.to_string() &lt;&lt; std::endl;</div><div class="line">        <span class="comment">//async: </span></div><div class="line">        <span class="comment">//_counter_client-&gt;begin_read(req);</span></div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">if</span> (err1 == 0 &amp;&amp; err2 == 0)</div><div class="line">    {</div><div class="line">        assert (resp2 == resp1);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><div class="fragment"><div class="line">[apps.client]</div><div class="line">name = client</div><div class="line">type = counter_client</div><div class="line">arguments = localhost 27001</div><div class="line">count = 2</div><div class="line">run = <span class="keyword">true</span></div><div class="line"></div><div class="line">[core]</div><div class="line">tool = simulator</div><div class="line">toollets = tracer, fault_injector</div><div class="line"></div><div class="line">; logging_factory_name = dsn::tools::screen_logger</div><div class="line"></div><div class="line">[tools.simulator]</div><div class="line">random_seed = 0</div></div><!-- fragment --><p>Note despite that we have multiple threads in the server serving the requests, the simulator can still run the whole system as if it were a single thread to ensure a deterministic execution. We set <b>use_given_random_seed = false</b> in this case, so each run of the system is a different sequence. We usually start many runs simultaneously to speed-up the test. An example can be find <a href="https://github.com/Microsoft/rDSN/blob/master/src/apps/replication/exe/test.cmd">here</a> which we use for testing our replication framework.</p>
<p>If some of the instances expose bugs (by hitting assertions or crashes), the first thing to do is look into the first logging file log.1.txt, find the random seed for this run, and then go to STEP 6 with bugs reproduced for debugging.</p>
<div class="fragment"><div class="line">00:00:00.000(0) system.io-thrd.5d30: env.provider.simulator, simulation.random seed <span class="keywordflow">for</span> <span class="keyword">this</span> round is 225948868</div></div><!-- fragment --><h3>STEP 9. Understanding the performance using the profiler tool</h3>
<p>rDSN provides the profiler toollet to understand the performance of the system: including latency measurement for each kind of RPC calls, and throughput measurements for the thread pools as well as the low level components (e.g., network, disk AIO). Similar to the tracer toollet, here is the way we enable the profiler. We illustrate how to extract the profiling results next using cli tool provided by rDSN.</p>
<div class="fragment"><div class="line">[core]</div><div class="line"></div><div class="line">;tool = simulator</div><div class="line">tool = nativerun</div><div class="line">toollets = profiler</div><div class="line">;toollets = tracer, profiler, fault_injector</div><div class="line">pause_on_start = <span class="keyword">false</span></div></div><!-- fragment --><h3>STEP 10. Operate your system with local and remote cli</h3>
<p>The cli tool provides a console with which developers can get information from all tools (cli exposes API as part of the Tool API interface, so tools can register their commands), and possibly control their behavior (e.g., switch on/off). Both local and remote cli tools are enabled via configuration. Note we also need to ensure logs are dumped to files instead of on-screen to avoid interference with local cli console I/O.</p>
<div class="fragment"><div class="line">[core]</div><div class="line">cli_local = <span class="keyword">true</span></div><div class="line">cli_remote = true</div><div class="line">;logging_factory_name = dsn::tools::screen_logger</div></div><!-- fragment --><p>// TODO: cli with fault injection, tracer, and profiler By using local or remote cli (via our bin tool <code>dsn.cli</code>), you can get a console to query and/or control the local/remote processes. Note when using the remote cli, you need to use <code>[core]tool=nativerun</code> so remote cli can connect to it. On both cases, simply type 'help' to start.</p>
<h3>STEP 11. Check global correctness using global assertion across nodes</h3>
<p>// TODO:</p>
<h3>STEP 12. Handle system overloading using admission controller</h3>
<p>A simple approach is to limit the upper bound of the task queue size.</p>
<div class="fragment"><div class="line">[threadpool.THREAD_POOL_DEFAULT]</div><div class="line">name = <span class="keywordflow">default</span></div><div class="line">partitioned = <span class="keyword">false</span></div><div class="line">max_input_queue_length = 1024</div></div><!-- fragment --><p>// TODO: You can also register your own admission controller and set it in the configuration file.</p>
<h3>STEP 13. Plug-in your own low level components (optional)</h3>
<p>You probably already notice that there is a configuration above like "[core] logging_factory_name = dsn::tools::screen_logger". In this case, we are specifying that we would like to use the <b>screen_logger</b> as our logging provider. You may also change it to "dsn::tools::simple_logger" as a file logger. Or even better, you may already have your own logging system already, and rDSN allows easy integration as follows.</p>
<h4>13.1. Follow the example in **/src/tools/common/simple_logger.h/.cpp** to implement a new logging provider by wrapping your existing logger.</h4>
<h4>13.2. In counter.main.cpp, include the header file of what you just implemented, and register the provider to rDSN.</h4>
<div class="fragment"><div class="line">{C++}</div><div class="line"> 11 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div><div class="line"> 12 {</div><div class="line"> 13     <span class="comment">// register all possible service apps</span></div><div class="line"> 14     dsn::service::system::register_service&lt;::dsn::example::counter_server_app&gt;(<span class="stringliteral">&quot;counter_server&quot;</span>);</div><div class="line"> 15     dsn::service::system::register_service&lt;::dsn::example::counter_client_app&gt;(<span class="stringliteral">&quot;counter_client&quot;</span>);</div><div class="line"> 16</div><div class="line"> 17     <span class="comment">// register all possible tools and toollets</span></div><div class="line"> 18     dsn::tools::register_tool&lt;dsn::tools::nativerun&gt;(<span class="stringliteral">&quot;nativerun&quot;</span>);</div><div class="line"> 19     dsn::tools::register_tool&lt;dsn::tools::simulator&gt;(<span class="stringliteral">&quot;simulator&quot;</span>);</div><div class="line"> 20     dsn::tools::register_toollet&lt;dsn::tools::tracer&gt;(<span class="stringliteral">&quot;tracer&quot;</span>);</div><div class="line"> 21     dsn::tools::register_toollet&lt;dsn::tools::profiler&gt;(<span class="stringliteral">&quot;profiler&quot;</span>);</div><div class="line"> 22     dsn::tools::register_toollet&lt;dsn::tools::fault_injector&gt;(<span class="stringliteral">&quot;fault_injector&quot;</span>);</div><div class="line"> 23</div><div class="line"> 24     <span class="comment">// register customized components</span></div><div class="line"> 25     dsn::tools::register_component_provider&lt;new_logger&gt;(<span class="stringliteral">&quot;new_logger&quot;</span>);</div><div class="line"> 26</div><div class="line"> 27     <span class="comment">// specify what services and tools will run in config file, then run</span></div><div class="line"> 28     dsn::service::system::run(<span class="stringliteral">&quot;config.ini&quot;</span>);</div><div class="line"> 29     ::getchar();</div><div class="line"> 30</div><div class="line"> 31     <span class="keywordflow">return</span> 0;</div><div class="line"> 32 }</div></div><!-- fragment --><h4>13.3. In config.ini, specify the logging provider, and it is done.</h4>
<div class="fragment"><div class="line">[core]</div><div class="line">logging_factory_name = new_logger</div></div><!-- fragment --><p>rDSN is designed to be open, and many of its components can be replaced like this. Check out <a href="https://github.com/Microsoft/rDSN/wiki/Tool-API:-Component-Providers,-Join-Points,-and-State-Extensions">here</a> to see a lot more and follow the examples under **/src/tools/common/** to plug-in your own.</p>
<h3>STEP 14. Connect the service with other languages (optional)</h3>
<p>Although the current rDSN only supports C++ to implement the service code, it allows clients to be in other languages such as Java, C#, Python, or even others. The way it implements those is to allow inter-operation with clients generated by the existing tools such as Apache Thrift (with the same .thrift definition).</p>
<p>For this example, you may define a macro called <b>DSN_NOT_USE_DEFAULT_SERIALIZATION</b> for compilation or go to the generated file <b>counter.types.h</b>, uncomment the line defining this macro. The effect is as the name indicates, and it requires <b>counter_type.h/.cpp</b> generated by running <b>thrift &ndash;gen cpp counter.thrift</b>. Note in this case we also need to configure the network to accept Thrift network message headers (i.e., message_format% = thrift).</p>
<div class="fragment"><div class="line">~/projects/rdsn/tutorial$ thrift --gen cpp counter.thrift</div><div class="line">~/projects/rdsn/tutorial$ cp gen-cpp/counter_types.* counter/</div><div class="line">~/projects/rdsn/tutorial$ cd counter/build</div><div class="line">~/projects/rdsn/tutorial/counter/build$ make</div></div><!-- fragment --><div class="fragment"><div class="line">[network.27001]</div><div class="line">; channel = message_format, network_provider_name, buffer_block_size</div><div class="line">;RPC_CHANNEL_TCP = NET_HDR_DSN,dsn::tools::asio_network_provider, 65536</div><div class="line">RPC_CHANNEL_TCP = NET_HDR_THRIFT,dsn::tools::asio_network_provider, 65536</div></div><!-- fragment --><h3>STEP 15. Open service with multiple ports (optional)</h3>
<p>rDSN also supports opening multiple ports for the same services, and each port may allow different data transmission protocols. Specifically, the message headers can be different, but the data encoding/decoding must be the same (so far). One possible scenario is that we open a dedicated port for external request handling (possibly with a different message protocol). Following is an example where we open two ports for our sample application, and allow both rDSN's message protocol and standard Thrift binary protocol.</p>
<div class="fragment"><div class="line">[apps.counter.server]</div><div class="line">name = counter.server</div><div class="line">type = counter_server</div><div class="line">arguments = </div><div class="line">ports = 27001,27002</div><div class="line">run = <span class="keyword">true</span></div><div class="line"></div><div class="line">[network.27001]</div><div class="line">; channel = message_format, network_provider_name, buffer_block_size</div><div class="line">RPC_CHANNEL_TCP = NET_HDR_DSN,dsn::tools::asio_network_provider, 65536</div><div class="line"></div><div class="line">[network.27002]</div><div class="line">; channel = message_format, network_provider_name, buffer_block_size</div><div class="line">RPC_CHANNEL_TCP = NET_HDR_THRIFT,dsn::tools::asio_network_provider, 65536</div></div><!-- fragment --><h3>STEP 16. Find more information about the config.ini (optional)</h3>
<p>Please click <a href="https://github.com/Microsoft/rDSN/wiki/Find-useful-information-of-config.ini">here</a> </p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
